# Heroes Battle

## GeneratePreset
При реализации метода generate() интерфейса GeneratePreset использовался жадный алгоритм по коэффициенту атака/стоимость + здоровье/стоимость.

1. Вначале происходит сортировка юнитов по их эффективности: O(n*log(n)), так как n = 4 - константа количества типов юнитов, то O(4*log(4)) = O(1)
2. Инициализируется массив доступных для размещения позиций: O(x * y), где x = 3 - константа количества столбцов для размещения юнитов, y = 21 - количество рядов и тоже константа. Тогда O(x*y) = O(63) = O(1)
3. Основной цикл заполнения армии: O(m*n), где n - общее число типов юнитов, m - максимальное число юнитов в армии. m в самом худшем случае равен 1500/20 = 75, но учитывая размер доступного поля - 63 и ограничения на количество юнитов - 11, m = 43 в худшем случае.
   Внешний while работает до момента, когда кончатся доступные очки, то есть m раз.
   Вложенный в него for работает n раз, заполняя каждого тип юнита.
   Еще один вложенный for срабатывает 3 раза (по количеству доступных колонок из условия), случайно выбирая место для юнита.
   То есть сложность O(m * n * 3). А так как n = 4 - константа количества типов юнитов, то его сложность O(m).

Тогда, итоговая сложность O(1) + O(1) + O(m) = O(m)

## SimulateBattle
В симуляции битвы используется циклическая обработка с динамическим формированием порядка хода и проверкой статуса юнитов перед каждым действием.

n - общее количество юнитов в битве
r  - количество раундов. В худшем случае r = n, когда умирает только один за раунд

В каждом раунде:
1. Сбор живых юнитов - O(n)
2. Сортировка по убыванию атаки - O(n * log(n))
3. Обработка ходов - O(n)

Итого за раунд: O(n) + O(n * log(n)) + O(n) = O(n * log(n))

Так как в худшем случае раундов может быть r = n, итоговая сложность составит: O(n * n * log(n)) = O(n^2 * log(n))

## SuitableForAttackUnitsFinder
При определении доступных для атаки юнитов используется линейный проход по столбцам с проверкой наличия соседей справа/слева в зависимости от атакуемой армии.

m - количество юнитов в армии противника.

Для любой из армий алгоритм работает следующим образом:
1. Внешний цикл for проходит по колонкам, от конца к началу. Колонок 3 по условию.
2. Внутри вложенный for проходит по юнитам в отдельно взятой колонке и проверяет свободна ли позиция справа или слева (в зависимости от армии) от них.
3. При проверке определяется наличие юнита на соседней позиции через проверку наличия такой же y-координаты в соседнем столбце. При этом все занятые y-координаты хранятся в HashSet, что понижает сложность такого поиска до O(1).

То есть, после того как внешний for обойдет все 3 колонки, будут проанализированы ровно m юнитов.

Таким образом, итоговая сложность составляет O(3 * m) = O(m)

## UnitTargetPathFinder
При реализации поиска кратчайшего пути был выбран алгоритм BFS.

WIDTH = 27 - ширина поля
HEIGHT = 21 - высота поля

Сначала заполняется массив с уже занятыми юнитами клетками.

Далее начинается алгоритм BFS:
Обходим вершины в цикле while. Каждая вершина посещается максимум по одному разу. Сложность = количество вершин * количество ребер. Количество ребер в данном графе ~ 2 * WIDTH * HEIGHT. Но так как каждое просматривается дважды при обходе, то количество ребер ~ 4 * WIDTH * HEIGHT. 
Соответственно, сложность получается O(WIDTH * HEIGHT + 4 * WIDTH * HEIGHT) = O(WIDTH * HEIGHT).

В конце восстанавливаем путь, что также сложность не более O(WIDTH * HEIGHT).

Таким образом? итоговая сложность получается O(WIDTH * HEIGHT + WIDTH * HEIGHT) = O(WIDTH * HEIGHT)
